/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const util = require("util");
const webpackOptionsSchema = require("../schemas/WebpackOptions.json");
// Webpack çš„å…¨å±€æ§åˆ¶
const Compiler = require("./Compiler");
const MultiCompiler = require("./MultiCompiler");
const WebpackOptionsApply = require("./WebpackOptionsApply");
const {
	applyWebpackOptionsDefaults,
	applyWebpackOptionsBaseDefaults
} = require("./config/defaults");
const { getNormalizedWebpackOptions } = require("./config/normalization");
const NodeEnvironmentPlugin = require("./node/NodeEnvironmentPlugin");
const validateSchema = require("./validateSchema");
const { yellow, magenta } = require('colorette');
const console = require('customLog');

/** @typedef {import("../declarations/WebpackOptions").WebpackOptions} WebpackOptions */
/** @typedef {import("./Compiler")} Compiler */
/** @typedef {import("./Compiler").WatchOptions} WatchOptions */
/** @typedef {import("./MultiCompiler")} MultiCompiler */
/** @typedef {import("./MultiStats")} MultiStats */
/** @typedef {import("./Stats")} Stats */

/**
 * @template T
 * @callback Callback
 * @param {Error=} err
 * @param {T=} stats
 * @returns {void}
 */

/**
 * @param {WebpackOptions[]} childOptions options array
 * @returns {MultiCompiler} a multi-compiler
 */
const createMultiCompiler = childOptions => {
	const compilers = childOptions.map(options => createCompiler(options));
	const compiler = new MultiCompiler(compilers);
	for (const childCompiler of compilers) {
		if (childCompiler.options.dependencies) {
			compiler.setDependencies(
				childCompiler,
				childCompiler.options.dependencies
			);
		}
	}
	return compiler;
};

/**
 * @param {WebpackOptions} rawOptions options object
 * @returns {Compiler} a compiler
 */
const createCompiler = rawOptions => {
	const options = getNormalizedWebpackOptions(rawOptions);
	console.log("ğŸŒº 20. å¾—åˆ°æ ‡å‡†åŒ–options, options (å¤ªé•¿äº†) å…¶ä¸­ï¼Œ options.context: ", options.context);
	applyWebpackOptionsBaseDefaults(options);
	console.log("ğŸŒº 21. options.context ä¸å­˜åœ¨æ—¶ï¼Œå°†å®ƒè®¾ç½®ä¸ºå½“å‰ç›®å½• options.context: ", options.context);
	// åˆ›å»º compiler
	const compiler = new Compiler(options.context);
	console.log("ğŸŒº 22. åˆ›å»ºcompilerğŸ’¡ å‚æ•°: ", options.context, `ç»è¿‡ Compiler æ„é€ å‡½æ•°ï¼Œcomplier ä¸Šæ³¨å†Œäº†é’©å­ hookï¼Œ é€šè¿‡ ${yellow('tapable')} è¿›è¡Œç®¡ç† `);
	compiler.options = options;
	new NodeEnvironmentPlugin({
		infrastructureLogging: options.infrastructureLogging
	}).apply(compiler);
	console.log("ğŸŒº 23. æ³¨å†Œ pluginï¼Œä¸º plugin ä¼ å…¥ compiler ", options.plugins);
	// æ³¨å†Œ plugin
	if (Array.isArray(options.plugins)) {
		for (const plugin of options.plugins) {
			if (typeof plugin === "function") {
				// plugin æ˜¯å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨ï¼Œå¹¶ä¼ å…¥ compiler
				plugin.call(compiler, compiler);
			} else {
				// plugin ä¸ºéå‡½æ•°ï¼Œè¦æ±‚ plugin ä¸Šæ³¨å†Œ apply å‡½æ•°ï¼Œplugin å¯ä»¥ä» apply ä¸­æ‹¿åˆ° compiler
				plugin.apply(compiler);
			}
		}
	}
	// åº”ç”¨ webpack é»˜è®¤é€‰é¡¹é…ç½®
	applyWebpackOptionsDefaults(options);

	console.log(magenta('    ğŸ¶ 1. hooks: environment call'));
	compiler.hooks.environment.call();
	console.log(magenta('    ğŸ¶ 2. hooks: afterEnvironment call'));
	compiler.hooks.afterEnvironment.call();

	new WebpackOptionsApply().process(options, compiler);
	// è°ƒç”¨åˆå§‹åŒ–é’©å­
	console.log(magenta('    ğŸ¶ 3. hooks: initialize call'));
	compiler.hooks.initialize.call();
	return compiler;
};

/**
 * @callback WebpackFunctionSingle
 * @param {WebpackOptions} options options object
 * @param {Callback<Stats>=} callback callback
 * @returns {Compiler} the compiler object
 */

/**
 * @callback WebpackFunctionMulti
 * @param {WebpackOptions[]} options options objects
 * @param {Callback<MultiStats>=} callback callback
 * @returns {MultiCompiler} the multi compiler object
 */

const webpack = /** @type {WebpackFunctionSingle & WebpackFunctionMulti} */ ((
	options,
	callback
) => {
	console.log('--------------------------------------------------------');
	console.log('ğŸŒº 19. è¿›å…¥ webpackï¼Œå¼€å§‹åˆ›å»º complierï¼Œå¾—åˆ°å‚æ•° options: \n', options, '\n callback: ',  callback);
	const create = () => {
		// æ£€éªŒæ ¼å¼æ˜¯å¦æ­£ç¡®
		validateSchema(webpackOptionsSchema, options);
		/** @type {MultiCompiler|Compiler} */
		let compiler;
		let watch = false;
		/** @type {WatchOptions|WatchOptions[]} */
		let watchOptions;
		// å¤šä¸ªé…ç½®
		if (Array.isArray(options)) {
			/** @type {MultiCompiler} */
			compiler = createMultiCompiler(options);
			watch = options.some(options => options.watch);
			watchOptions = options.map(options => options.watchOptions || {});
			console.log('ğŸŒº 24. åˆ›å»ºå‡ºå¤šé…ç½® complier, å¾—åˆ°: compiler, watch: ', watch, 'watchOptions: ', watchOptions);
		} else {
			/** @type {Compiler} */
			compiler = createCompiler(options);
			watch = options.watch;
			watchOptions = options.watchOptions || {};
			console.log('ğŸŒº 24. åˆ›å»ºå‡ºå•é…ç½® complier, å¾—åˆ°: compiler, watch: ', watch, 'watchOptions: ', watchOptions);
		}
		return { compiler, watch, watchOptions };
	};
	if (callback) {
		try {
			const { compiler, watch, watchOptions } = create();
			console.log('--------------------------------------------------------');
			if (watch) {
				compiler.watch(watchOptions, callback);
			} else {
				// å¼€å§‹æ„å»º
				compiler.run((err, stats) => {
					compiler.close(err2 => {
						callback(err || err2, stats);
					});
				});
			}
			return compiler;
		} catch (err) {
			process.nextTick(() => callback(err));
			return null;
		}
	} else {
		const { compiler, watch } = create();
		if (watch) {
			util.deprecate(
				() => {},
				"A 'callback' argument need to be provided to the 'webpack(options, callback)' function when the 'watch' option is set. There is no way to handle the 'watch' option without a callback.",
				"DEP_WEBPACK_WATCH_WITHOUT_CALLBACK"
			)();
		}
		return compiler;
	}
});

module.exports = webpack;
